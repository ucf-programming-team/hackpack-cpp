{
    "BIT.h": {
        "body": [
            "template <typename T>",
            "struct BIT {",
            "\tvector<T> s;",
            "\tint n;",
            "\tBIT(int n): s(n + 1), n(n) {}",
            "\tvoid update(int i, T v) {",
            "\t\tfor (i++; i <= n; i += i & -i) s[i] += v;",
            "\t}",
            "\tT query(int i) {",
            "\t\tT ans = 0;",
            "\t\tfor (i++; i; i -= i & -i) ans += s[i];",
            "\t\treturn ans;",
            "\t}",
            "\tT query(int l, int r) { return query(r) - query(l - 1); }",
            "\tint kth(T k) { // returns n if k > sum of tree",
            "\t\tif (k <= 0) return -1;",
            "\t\tint i = 0;",
            "\t\tfor (int pw = 1 << __lg(n); pw; pw >>= 1)",
            "\t\t\tif (i + pw <= n && s[i + pw] < k) k -= s[i += pw];",
            "\t\treturn i;",
            "\t}",
            "};"
        ],
        "description": "Query [l, r] sums, and point updates.\nkth() returns the smallest index i s.t. query(0, i) >= k",
        "prefix": [
            "hack_BIT"
        ]
    },
    "DSU.h": {
        "body": [
            "struct DSU {",
            "\tvector<int> s;",
            "\tDSU(int n): s(n, -1) {}",
            "\tint find(int i) { return s[i] < 0 ? i : s[i] = find(s[i]); }",
            "\tbool join(int a, int b) {",
            "\t\ta = find(a), b = find(b);",
            "\t\tif (a == b) return false;",
            "\t\tif (s[a] > s[b]) swap(a, b);",
            "\t\ts[a] += s[b], s[b] = a;",
            "\t\treturn true;",
            "\t}",
            "\tint size(int i) { return -s[find(i)]; }",
            "\tbool same(int a, int b) { return find(a) == find(b); }",
            "};"
        ],
        "description": "Maintains union of disjoint sets",
        "prefix": [
            "hack_DSU"
        ]
    },
    "Dijkstra.h": {
        "body": [
            "template <class T>",
            "pair<vector<bool>, vector<T>> dijkstra(",
            " const vector<vector<pair<int, T>>>& adj, int s) {",
            "\tusing ST = pair<T, int>;",
            "\tpriority_queue<ST, vector<ST>, greater<ST>> q;",
            "\tvector<T> dist(adj.size());",
            "\tvector<bool> seen(adj.size());",
            "\tq.emplace(T{}, s);",
            "\tseen[s] = 1;",
            "\twhile (!q.empty()) {",
            "\t\tauto [d, u] = q.top();",
            "\t\tq.pop();",
            "\t\tif (dist[u] < d) continue;",
            "\t\tfor (auto [v, w] : adj[u])",
            "\t\t\tif (!seen[v] || d + w < dist[v]) {",
            "\t\t\t\tq.emplace(dist[v] = d + w, v);",
            "\t\t\t\tseen[v] = 1;",
            "\t\t\t}",
            "\t}",
            "\treturn {seen, dist};",
            "}"
        ],
        "description": "Computes shortest paths from s\nto any node reachable from s.\nPass in an adjacency list of pairs (node, weight).",
        "prefix": [
            "hack_Dijkstra"
        ]
    },
    "Dinic.h": {
        "body": [
            "struct Dinic {",
            "\t// disable scaling when max flow/capacity is small, or",
            "\t// sometimes on random data",
            "\tconst static bool SCALING = true;",
            "\tstruct Edge {",
            "\t\tint v, dual;",
            "\t\tll cap, res;",
            "\t\tconstexpr ll flow() { return max(cap - res, 0ll); }",
            "\t};",
            "\tint n, s, t;",
            "\tvector<int> lvl, q, blk;",
            "\tvector<vector<Edge>> adj;",
            "\tvector<pair<int, int>> edges;",
            "\tDinic(int n) : n(n + 2), s(n++), t(n++), q(n), adj(n) {}",
            "\tint add(int u, int v, ll cap, ll flow = 0) {",
            "\t\tadj[u].push_back({v, int(adj[v].size()), cap, cap - flow});",
            "\t\tadj[v].push_back({u, int(adj[u].size()) - 1, 0, 0});",
            "\t\tedges.emplace_back(u, adj[u].size() - 1);",
            "\t\treturn edges.size() - 1; // this Edge's ID",
            "\t}",
            "\tll dfs(int u, ll in) {",
            "\t\tif (u == t || !in) return in;",
            "\t\tll flow = 0;",
            "\t\tfor (auto& e : adj[u]) {",
            "\t\t\tif (e.res && !blk[e.v] && lvl[e.v] == lvl[u] - 1)",
            "\t\t\t\tif (ll out = dfs(e.v, min(in, e.res))) {",
            "\t\t\t\t\tflow += out, in -= out, e.res -= out;",
            "\t\t\t\t\tadj[e.v][e.dual].res += out;",
            "\t\t\t\t\tif (!in) return flow;",
            "\t\t\t\t}",
            "\t\t}",
            "\t\tblk[u] = 1;",
            "\t\treturn flow;",
            "\t}",
            "\tll flow() {",
            "\t\tll flow = 0;",
            "\t\tq[0] = t;",
            "\t\tfor (int B = SCALING * 30; B >= 0; B--) do {",
            "\t\t\t\tlvl = blk = vector<int>(n);",
            "\t\t\t\tint qi = 0, qe = lvl[t] = 1;",
            "\t\t\t\twhile (qi < qe && !lvl[s]) {",
            "\t\t\t\t\tint u = q[qi++];",
            "\t\t\t\t\tfor (auto& e : adj[u])",
            "\t\t\t\t\t\tif (!lvl[e.v] && adj[e.v][e.dual].res >> B)",
            "\t\t\t\t\t\t\tq[qe++] = e.v, lvl[e.v] = lvl[u] + 1;",
            "\t\t\t\t}",
            "\t\t\t\tif (lvl[s]) flow += dfs(s, LLONG_MAX);",
            "\t\t\t} while (lvl[s]);",
            "\t\treturn flow;",
            "\t}",
            "\tEdge& get(int id) { // get Edge object from its ID",
            "\t\treturn adj[edges[id].first][edges[id].second];",
            "\t}",
            "\tvoid clear() {",
            "\t\tfor (auto& it : adj)",
            "\t\t\tfor (auto& e : it) e.res = e.cap;",
            "\t}",
            "\tbool leftOfMinCut(int u) { return lvl[u] == 0; }",
            "\t// d is a list of vertex demands, d[u] = flow in - flow out",
            "\t// negative if u is a source, positive if u is a sink",
            "\tbool circulation(vector<ll> d = {}) {",
            "\t\td.resize(n);",
            "\t\tvector<int> circEdges;",
            "\t\tDinic g(n);",
            "\t\tfor (int u = 0; u < n; u++)",
            "\t\t\tfor (auto& e : adj[u]) {",
            "\t\t\t\td[u] += e.flow(), d[e.v] -= e.flow();",
            "\t\t\t\tif (e.res) circEdges.push_back(g.add(u, e.v, e.res));",
            "\t\t\t}",
            "\t\tint tylerEdge = g.add(t, s, LLONG_MAX, 0);",
            "\t\tll flow = 0;",
            "\t\tfor (int u = 0; u < n; u++)",
            "\t\t\tif (d[u] < 0)",
            "\t\t\t\tg.add(g.s, u, -d[u]);",
            "\t\t\telse if (d[u] > 0)",
            "\t\t\t\tg.add(u, g.t, d[u]), flow += d[u];",
            "\t\tif (flow != g.flow()) return false;",
            "\t\tint i = 0; // reconstruct the flow into this graph",
            "\t\tfor (int u = 0; u < n; u++)",
            "\t\t\tfor (auto& e : adj[u])",
            "\t\t\t\tif (e.res) e.res -= g.get(circEdges[i++]).flow();",
            "\t\treturn true;",
            "\t}",
            "};"
        ],
        "description": "Max flow algorithm. Can find a valid\ncirculation given vertex and/or edge demands. Time:\n$O(VE\\log{U})$",
        "prefix": [
            "hack_Dinic"
        ]
    },
    "Fraction.h": {
        "body": [
            "template <typename T>",
            "struct Q {",
            "\tT a, b;",
            "\tQ(T p, T q = 1) {",
            "\t\tT g = gcd(p, q);",
            "\t\ta = p / g;",
            "\t\tb = q / g;",
            "\t\tif (b < 0) a = -a, b = -b;",
            "\t}",
            "\tT gcd(T x, T y) const { return __gcd(x, y); }",
            "\tQ operator+(const Q& o) const {",
            "\t\treturn {a * o.b + o.a * b, b * o.b};",
            "\t}",
            "\tQ operator-(const Q& o) const {",
            "\t\treturn *this + Q(-o.a, o.b);",
            "\t}",
            "\tQ operator*(const Q& o) const { return {a * o.a, b * o.b}; }",
            "\tQ operator/(const Q& o) const { return *this * Q(o.b, o.a); }",
            "\tQ recip() const { return {b, a}; }",
            "\tint signum() const { return (a > 0) - (a < 0); }",
            "\tbool operator<(const Q& o) const {",
            "\t\treturn a * o.b < o.a * b;",
            "\t}",
            "\tfriend ostream& operator<<(ostream& cout, const Q& o) {",
            "\t\treturn cout << o.a << \"/\" << o.b;",
            "\t}",
            "};"
        ],
        "description": "Struct for representing fractions/rationals.\nAll ops are $O(\\log N)$ due to GCD in constructor.\nUses cross multiplication.",
        "prefix": [
            "hack_Fraction"
        ]
    },
    "FractionOverflow.h": {
        "body": [
            "template <typename T>",
            "struct QO {",
            "\tT a, b;",
            "\tQO(T p, T q = 1) {",
            "\t\tT g = gcd(p, q);",
            "\t\ta = p / g;",
            "\t\tb = q / g;",
            "\t\tif (b < 0) a = -a, b = -b;",
            "\t}",
            "\tT gcd(T x, T y) const { return __gcd(x, y); }",
            "\tQO operator+(const QO& o) const {",
            "\t\tT g = gcd(b, o.b), bb = b / g, obb = o.b / g;",
            "\t\treturn {a * obb + o.a * bb, o.b * obb};",
            "\t}",
            "\tQO operator-(const QO& o) const {",
            "\t\treturn *this + QO(-o.a, o.b);",
            "\t}",
            "\tQO operator*(const QO& o) const {",
            "\t\tT g1 = gcd(a, o.b), g2 = gcd(o.a, b);",
            "\t\treturn {(a / g1) * (o.a / g2), (b / g2) * (o.b / g1)};",
            "\t}",
            "\tQO operator/(const QO& o) const {",
            "\t\treturn *this * QO(o.b, o.a);",
            "\t}",
            "\tQO recip() const { return {b, a}; }",
            "\tint signum() const { return (a > 0) - (a < 0); }",
            "\tstatic bool lessThan(T a, T b, T x, T y) {",
            "\t\tif (a / b != x / y) return a / b < x / y;",
            "\t\tif (x % y == 0) return false;",
            "\t\tif (a % b == 0) return true;",
            "\t\treturn lessThan(y, x % y, b, a % b);",
            "\t}",
            "\tbool operator<(const QO& o) const {",
            "\t\tif (this->signum() != o.signum() || a == 0) return a < o.a;",
            "\t\tif (a < 0)",
            "\t\t\treturn lessThan(abs(o.a), o.b, abs(a), b);",
            "\t\telse",
            "\t\t\treturn lessThan(a, b, o.a, o.b);",
            "\t}",
            "\tfriend ostream& operator<<(ostream& cout, const QO& o) {",
            "\t\treturn cout << o.a << \"/\" << o.b;",
            "\t}",
            "};"
        ],
        "description": "Safer struct for representing\nfractions/rationals. Comparison is 100\\% overflow safe;\nother ops are safer but can still overflow. All ops are\n$O(\\log N)$.",
        "prefix": [
            "hack_FractionOverflow"
        ]
    },
    "KDBIT.h": {
        "body": [
            "template <class T, int... Ns>",
            "struct BIT {",
            "\tT val = 0;",
            "\tvoid update(T v) { val += v; }",
            "\tT query() { return val; }",
            "};",
            "template <class T, int N, int... Ns>",
            "struct BIT<T, N, Ns...> {",
            "\tBIT<T, Ns...> bit[N + 1];",
            "\t// map<int, BIT<T, Ns...>> bit;",
            "\t// if the memory use is too high",
            "\ttemplate <class... Args>",
            "\tvoid update(int i, Args... args) {",
            "\t\tfor (i++; i <= N; i += i & -i) bit[i].update(args...);",
            "\t}",
            "\ttemplate <class... Args>",
            "\tT query(int i, Args... args) {",
            "\t\tT ans = 0;",
            "\t\tfor (i++; i; i -= i & -i) ans += bit[i].query(args...);",
            "\t\treturn ans;",
            "\t}",
            "\ttemplate <class... Args,",
            "\t\t\t\t\t\tenable_if_t<(sizeof...(Args) ==",
            "\t\t\t\t\t\t\t\t\t\t\t\t 2 * sizeof...(Ns))>* = nullptr>",
            "\tT query(int l, int r, Args... args) {",
            "\t\treturn query(r, args...) - query(l - 1, args...);",
            "\t}",
            "};"
        ],
        "description": "$k$-dimensional BIT. \\texttt{BIT<int, N, M>}\ngives an $N \\times M$ BIT.\n\\\\ Query: \\texttt{bit.query(x1, x2, y1, y2)} Update:\n\\texttt{bit.update(x, y, delta)} Time: $O(\\log^k n)$ Status:\nTested",
        "prefix": [
            "hack_KDBIT"
        ]
    },
    "NDimensionalVector.h": {
        "body": [
            "template <int D, typename T>",
            "struct Vec : public vector<Vec<D - 1, T>> {",
            "\tstatic_assert(D >= 1,",
            "\t\t\t\t\t\t\t\t\"Vector dimension must be greater than zero!\");",
            "\ttemplate <typename... Args>",
            "\tVec(int n = 0, Args... args):",
            "\t\tvector<Vec<D - 1, T>>(n, Vec<D - 1, T>(args...)) {}",
            "};",
            "template <typename T>",
            "struct Vec<1, T> : public vector<T> {",
            "\tVec(int n = 0, const T& val = T()): vector<T>(n, val) {}",
            "};"
        ],
        "prefix": [
            "hack_NDimensionalVector"
        ]
    },
    "PrimeSieve.h": {
        "body": [
            "const int MAX_PR = 5'000'000;",
            "bitset<MAX_PR> isprime;",
            "vector<int> primeSieve(int lim) {",
            "\tisprime.set();",
            "\tisprime[0] = isprime[1] = 0;",
            "\tfor (int i = 4; i < lim; i += 2) isprime[i] = 0;",
            "\tfor (int i = 3; i * i < lim; i += 2)",
            "\t\tif (isprime[i])",
            "\t\t\tfor (int j = i * i; j < lim; j += i * 2) isprime[j] = 0;",
            "\tvector<int> pr;",
            "\tfor (int i = 2; i < lim; i++)",
            "\t\tif (isprime[i]) pr.push_back(i);",
            "\treturn pr;",
            "}"
        ],
        "description": "Prime sieve for generating all primes up\nto a certain limit. isprime$[i]$ is true iff $i$ is a prime.",
        "prefix": [
            "hack_PrimeSieve"
        ]
    },
    "PrimeSieveFast.h": {
        "body": [
            "const int LIM = 1e8;",
            "bitset<LIM> isPrime;",
            "vector<int> primeSieve() {",
            "\tconst int S = round(sqrt(LIM)), R = LIM / 2;",
            "\tvector<int> pr = {2}, sieve(S + 1);",
            "\tpr.reserve(int(LIM / log(LIM) * 1.1));",
            "\tvector<pair<int, int>> cp;",
            "\tfor (int i = 3; i <= S; i += 2)",
            "\t\tif (!sieve[i]) {",
            "\t\t\tcp.push_back({i, i * i / 2});",
            "\t\t\tfor (int j = i * i; j <= S; j += 2 * i) sieve[j] = 1;",
            "\t\t}",
            "\tfor (int L = 1; L <= R; L += S) {",
            "\t\tarray<bool, S> block{};",
            "\t\tfor (auto& [p, idx] : cp)",
            "\t\t\tfor (int i = idx; i < S + L; idx = (i += p))",
            "\t\t\t\tblock[i - L] = 1;",
            "\t\tfor (int i = 0; i < min(S, R - L); i++)",
            "\t\t\tif (!block[i]) pr.push_back((L + i) * 2 + 1);",
            "\t}",
            "\tfor (int i : pr) isPrime[i] = 1;",
            "\treturn pr;",
            "}"
        ],
        "description": "Prime sieve for generating all primes smaller\nthan LIM.\n",
        "prefix": [
            "hack_PrimeSieveFast"
        ]
    },
    "RMQ.h": {
        "body": [
            "template <typename T, class Compare = less<T>>",
            "struct RMQ {",
            "\tvector<vector<T>> t;",
            "\tCompare cmp;",
            "\tRMQ(vector<T>& a): t(__lg(a.size()) + 1, a) {",
            "\t\tint n = a.size(), lg = __lg(n);",
            "\t\tfor (int k = 1, len = 1; k <= lg; k++, len <<= 1)",
            "\t\t\tfor (int i = 0; i + 2 * len - 1 < n; i++)",
            "\t\t\t\tt[k][i] = min(t[k - 1][i], t[k - 1][i + len], cmp);",
            "\t}",
            "\tT query(int a, int b) {",
            "\t\tint k = __lg(b - a + 1), len = 1 << k;",
            "\t\treturn min(t[k][a], t[k][b - len + 1], cmp);",
            "\t}",
            "};"
        ],
        "description": "Constant time subarray min/max queries for a\nfixed array Time: $O(n log n)$ initialization and $O(1)$\nqueries. Status: Tested",
        "prefix": [
            "hack_RMQ"
        ]
    },
    "SCCKosaraju.h": {
        "body": [
            "namespace SCCKosaraju {",
            "\tvector<vector<int>> adj, radj;",
            "\tvector<int> todo, comp;",
            "\tvector<bool> vis;",
            "\tvoid dfs1(int x) {",
            "\t\tvis[x] = 1;",
            "\t\tfor (int y : adj[x])",
            "\t\t\tif (!vis[y]) dfs1(y);",
            "\t\ttodo.push_back(x);",
            "\t}",
            "\tvoid dfs2(int x, int i) {",
            "\t\tcomp[x] = i;",
            "\t\tfor (int y : radj[x])",
            "\t\t\tif (comp[y] == -1) dfs2(y, i);",
            "\t}",
            "\tvector<int> scc(vector<vector<int>>& _adj) {",
            "\t\tadj = _adj;",
            "\t\tint time = 0, n = adj.size();",
            "\t\tcomp.resize(n, -1), radj.resize(n), vis.resize(n);",
            "\t\tfor (int x = 0; x < n; x++)",
            "\t\t\tfor (int y : adj[x]) radj[y].push_back(x);",
            "\t\tfor (int x = 0; x < n; x++)",
            "\t\t\tif (!vis[x]) dfs1(x);",
            "\t\treverse(todo.begin(), todo.end());",
            "\t\tfor (int x : todo)",
            "\t\t\tif (comp[x] == -1) dfs2(x, time++);",
            "\t\treturn comp;",
            "\t}",
            "}; // namespace SCCKosaraju"
        ],
        "description": "Finds strongly connected components of a\ndirected graph. Visits/indexes SCCs in\ntopological order.",
        "prefix": [
            "hack_SCCKosaraju"
        ]
    },
    "SCCTarjan.h": {
        "body": [
            "namespace SCCTarjan {",
            "\tvector<int> val, comp, z, cont;",
            "\tint Time, ncomps;",
            "\ttemplate <class G, class F>",
            "\tint dfs(int j, G& g, F& f) {",
            "\t\tint low = val[j] = ++Time, x;",
            "\t\tz.push_back(j);",
            "\t\tfor (auto e : g[j])",
            "\t\t\tif (comp[e] < 0) low = min(low, val[e] ?: dfs(e, g, f));",
            "\t\tif (low == val[j]) {",
            "\t\t\tdo {",
            "\t\t\t\tx = z.back();",
            "\t\t\t\tz.pop_back();",
            "\t\t\t\tcomp[x] = ncomps;",
            "\t\t\t\tcont.push_back(x);",
            "\t\t\t} while (x != j);",
            "\t\t\tf(cont);",
            "\t\t\tcont.clear();",
            "\t\t\tncomps++;",
            "\t\t}",
            "\t\treturn val[j] = low;",
            "\t}",
            "\ttemplate <class G, class F>",
            "\tvector<int> scc(G& g, F f) {",
            "\t\tint n = g.size();",
            "\t\tval.assign(n, 0);",
            "\t\tcomp.assign(n, -1);",
            "\t\tTime = ncomps = 0;",
            "\t\tfor (int i = 0; i < n; i++)",
            "\t\t\tif (comp[i] < 0) dfs(i, g, f);",
            "\t\treturn comp;",
            "\t}",
            "\ttemplate <class G> // convenience function w/o lambda",
            "\tvector<int> scc(G& g) {",
            "\t\treturn scc(g, [](auto& v) {});",
            "\t}",
            "} // namespace SCCTarjan"
        ],
        "description": "Finds strongly connected components of a\ndirected graph. Visits/indexes SCCs in reverse topological\norder.",
        "prefix": [
            "hack_SCCTarjan"
        ]
    },
    "Splay.h": {
        "body": [
            "struct node {",
            "\tnode *ch[2] = {0}, *p = 0;",
            "\tint cnt = 1, val;",
            "",
            "\tnode(int val, node* l = 0, node* r = 0):",
            "\t\tch{l, r}, val(val) {}",
            "};",
            "",
            "int cnt(node* x) { return x ? x->cnt : 0; }",
            "int dir(node* p, node* x) { return p && p->ch[0] != x; }",
            "void setLink(node* p, node* x, int d) {",
            "\tif (p) p->ch[d] = x;",
            "\tif (x) x->p = p;",
            "}",
            "",
            "node* update(node* x) {",
            "\tif (!x) return 0;",
            "\tx->cnt = 1 + cnt(x->ch[0]) + cnt(x->ch[1]);",
            "\tsetLink(x, x->ch[0], 0);",
            "\tsetLink(x, x->ch[1], 1);",
            "\treturn x;",
            "}",
            "",
            "void prop(node* x) {",
            "\tif (!x) return;",
            "\t// update(x); // needed if prop() can change subtree sizes",
            "}",
            "",
            "void rotate(node* x, int d) {",
            "\tif (!x || !x->ch[d]) return;",
            "\tnode *y = x->ch[d], *z = x->p;",
            "\tsetLink(x, y->ch[d ^ 1], d);",
            "\tsetLink(y, x, d ^ 1);",
            "\tsetLink(z, y, dir(z, x));",
            "\tupdate(x);",
            "\tupdate(y);",
            "}",
            "",
            "node* splay(node* x) {",
            "\twhile (x && x->p) {",
            "\t\tnode *y = x->p, *z = y->p;",
            "\t\t// prop(z), prop(y), prop(x); // needed for LCT",
            "\t\tint dy = dir(y, x), dz = dir(z, y);",
            "\t\tif (!z)",
            "\t\t\trotate(y, dy);",
            "\t\telse if (dy == dz)",
            "\t\t\trotate(z, dz), rotate(y, dy);",
            "\t\telse",
            "\t\t\trotate(y, dy), rotate(z, dz);",
            "\t}",
            "\treturn x;",
            "}",
            "",
            "// the returned node becomes the new root, update the root",
            "// pointer!",
            "node* nodeAt(node* x, int pos) {",
            "\tif (!x) return 0;",
            "\twhile (prop(x), cnt(x->ch[0]) != pos)",
            "\t\tif (pos < cnt(x->ch[0]))",
            "\t\t\tx = x->ch[0];",
            "\t\telse",
            "\t\t\tpos -= cnt(x->ch[0]) + 1, x = x->ch[1];",
            "\treturn splay(x);",
            "}",
            "",
            "node* merge(node* l, node* r) {",
            "\tif (!l || !r) return l ?: r;",
            "\tl = nodeAt(l, cnt(l) - 1);",
            "\tsetLink(l, r, 1);",
            "\treturn update(l);",
            "}",
            "",
            "// first is everything < pos, second is >= pos",
            "pair<node*, node*> split(node* t, int pos) {",
            "\tif (pos <= 0 || !t) return {0, t};",
            "\tif (pos > cnt(t)) return {t, 0};",
            "\tnode *l = nodeAt(t, pos - 1), *r = l->ch[1];",
            "\tif (r) l->ch[1] = r->p = 0;",
            "\treturn {update(l), update(r)};",
            "}",
            "",
            "// insert a new node between pos-1 and pos",
            "node* insert(node* t, int pos, int val) {",
            "\tauto [l, r] = split(t, pos);",
            "\treturn update(new node(val, l, r));",
            "}",
            "",
            "// apply lambda to all nodes in an inorder traversal",
            "template <class F>",
            "void each(node* x, F f) {",
            "\tif (x) prop(x), each(x->ch[0], f), f(x), each(x->ch[1], f);",
            "}"
        ],
        "description": "An implicit balanced BST. You only need to\nchange \\texttt{update()} and \\texttt{prop()}. \\\\\nIf used for link-cut tree, code everything up to\n\\texttt{splay()}. Time: amortized $O(\\log n)$ for all\noperations",
        "prefix": [
            "hack_Splay"
        ]
    },
    "Submasks.h": {
        "body": [
            "for (int mask = 0; mask < (1 << n); mask++)",
            "\tfor (int sub = mask; sub; sub = (sub - 1) & mask)",
            "// do thing"
        ],
        "prefix": [
            "hack_Submasks"
        ]
    },
    "ZValues.h": {
        "body": [
            "vector<int> zValues(string& s) {",
            "\tint n = ( int )s.length();",
            "\tvector<int> z(n);",
            "\tfor (int i = 1, l = 0, r = 0; i < n; ++i) {",
            "\t\tif (i <= r) z[i] = min(r - i + 1, z[i - l]);",
            "\t\twhile (i + z[i] < n && s[z[i]] == s[i + z[i]]) ++z[i];",
            "\t\tif (i + z[i] - 1 > r) l = i, r = i + z[i] - 1;",
            "\t}",
            "\treturn z;",
            "}"
        ],
        "prefix": [
            "hack_ZValues"
        ]
    },
    "template.cpp": {
        "body": [
            "#define all(x) begin(x), end(x)",
            "using namespace std;",
            "",
            "using ll = long long;",
            "",
            "int main() {",
            "\tcin.tie(0)->sync_with_stdio(0);",
            "\tcin.exceptions(cin.failbit);",
            "}"
        ],
        "prefix": [
            "hack_template"
        ]
    }
}