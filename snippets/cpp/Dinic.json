{
    "Dinic.h": {
        "body": [
            "struct Dinic {",
            "\t// disable scaling when max flow/capacity is small, or",
            "\t// sometimes on random data",
            "\tconst static bool SCALING = true;",
            "\tstruct Edge {",
            "\t\tint v, dual;",
            "\t\tll cap, res;",
            "\t\tconstexpr ll flow() { return max(cap - res, 0ll); }",
            "\t};",
            "\tint n, s, t;",
            "\tvector<int> lvl, q, blk;",
            "\tvector<vector<Edge>> adj;",
            "\tvector<pair<int, int>> edges;",
            "\tDinic(int n) : n(n + 2), s(n++), t(n++), q(n), adj(n) {}",
            "\tint add(int u, int v, ll cap, ll flow = 0) {",
            "\t\tadj[u].push_back({v, int(adj[v].size()), cap, cap - flow});",
            "\t\tadj[v].push_back({u, int(adj[u].size()) - 1, 0, 0});",
            "\t\tedges.emplace_back(u, adj[u].size() - 1);",
            "\t\treturn edges.size() - 1; // this Edge's ID",
            "\t}",
            "\tll dfs(int u, ll in) {",
            "\t\tif (u == t || !in) return in;",
            "\t\tll flow = 0;",
            "\t\tfor (auto& e : adj[u]) {",
            "\t\t\tif (e.res && !blk[e.v] && lvl[e.v] == lvl[u] - 1)",
            "\t\t\t\tif (ll out = dfs(e.v, min(in, e.res))) {",
            "\t\t\t\t\tflow += out, in -= out, e.res -= out;",
            "\t\t\t\t\tadj[e.v][e.dual].res += out;",
            "\t\t\t\t\tif (!in) return flow;",
            "\t\t\t\t}",
            "\t\t}",
            "\t\tblk[u] = 1;",
            "\t\treturn flow;",
            "\t}",
            "\tll flow() {",
            "\t\tll flow = 0;",
            "\t\tq[0] = t;",
            "\t\tfor (int B = SCALING * 30; B >= 0; B--) do {",
            "\t\t\t\tlvl = blk = vector<int>(n);",
            "\t\t\t\tint qi = 0, qe = lvl[t] = 1;",
            "\t\t\t\twhile (qi < qe && !lvl[s]) {",
            "\t\t\t\t\tint u = q[qi++];",
            "\t\t\t\t\tfor (auto& e : adj[u])",
            "\t\t\t\t\t\tif (!lvl[e.v] && adj[e.v][e.dual].res >> B)",
            "\t\t\t\t\t\t\tq[qe++] = e.v, lvl[e.v] = lvl[u] + 1;",
            "\t\t\t\t}",
            "\t\t\t\tif (lvl[s]) flow += dfs(s, LLONG_MAX);",
            "\t\t\t} while (lvl[s]);",
            "\t\treturn flow;",
            "\t}",
            "\tEdge& get(int id) { // get Edge object from its ID",
            "\t\treturn adj[edges[id].first][edges[id].second];",
            "\t}",
            "\tvoid clear() {",
            "\t\tfor (auto& it : adj)",
            "\t\t\tfor (auto& e : it) e.res = e.cap;",
            "\t}",
            "\tbool leftOfMinCut(int u) { return lvl[u] == 0; }",
            "\t// d is a list of vertex demands, d[u] = flow in - flow out",
            "\t// negative if u is a source, positive if u is a sink",
            "\tbool circulation(vector<ll> d = {}) {",
            "\t\td.resize(n);",
            "\t\tvector<int> circEdges;",
            "\t\tDinic g(n);",
            "\t\tfor (int u = 0; u < n; u++)",
            "\t\t\tfor (auto& e : adj[u]) {",
            "\t\t\t\td[u] += e.flow(), d[e.v] -= e.flow();",
            "\t\t\t\tif (e.res) circEdges.push_back(g.add(u, e.v, e.res));",
            "\t\t\t}",
            "\t\tint tylerEdge = g.add(t, s, LLONG_MAX, 0);",
            "\t\tll flow = 0;",
            "\t\tfor (int u = 0; u < n; u++)",
            "\t\t\tif (d[u] < 0)",
            "\t\t\t\tg.add(g.s, u, -d[u]);",
            "\t\t\telse if (d[u] > 0)",
            "\t\t\t\tg.add(u, g.t, d[u]), flow += d[u];",
            "\t\tif (flow != g.flow()) return false;",
            "\t\tint i = 0; // reconstruct the flow into this graph",
            "\t\tfor (int u = 0; u < n; u++)",
            "\t\t\tfor (auto& e : adj[u])",
            "\t\t\t\tif (e.res) e.res -= g.get(circEdges[i++]).flow();",
            "\t\treturn true;",
            "\t}",
            "};"
        ],
        "description": "Max flow algorithm. Can find a valid\ncirculation given vertex and/or edge demands. Time:\n$O(VE\\log{U})$",
        "prefix": [
            "hack_Dinic"
        ]
    }
}